{"version":3,"sources":["../src/index.js"],"names":["smosh","require","ImageminPlugin","constructor","options","test","minFileSize","maxFileSize","Infinity","cacheFolder","disable","onlyUseIfSmaller","timeout","externalImages","maxConcurrency","length","testFunction","context","sources","destination","fileName","apply","compiler","logger","getInfrastructureLogger","name","compilerOptions","onEmit","compilation","callback","getLogger","throttle","optimizeWebpackImages","err","console","log","hooks","emit","tapAsync","plugin","filename","assets","asset","assetSource","source","optimizedImageBuffer","compressor","RawSource","optimizeExternalImages","fullContext","path","resolve","invokedDestination","list","i","relativeFilePath","relative","fileData","result","writeFilePath","join","debug","file","data","percent","src_size","dest_size","imageData","imageBuffer","Buffer","isBuffer","from","originalSize","reject","contents","on","info","setTimeout","e"],"mappings":"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","file":"index.js","sourcesContent":["import path from 'path'\r\nimport { cpus } from 'os'\r\nimport map from 'lodash.map'\r\nimport RawSource from 'webpack-sources/lib/RawSource'\r\nimport createThrottle from 'async-throttle'\r\nconst smosh = require('smosh')\r\n\r\nimport {\r\n    buildTestFunction,\r\n    invokeIfFunction,\r\n    getFromCacheIfPossible,\r\n    readFile,\r\n    writeFile,\r\n    templatedFilePath\r\n} from './helpers.js'\r\n\r\nexport default class ImageminPlugin {\r\n    constructor (options = {}) {\r\n        const {\r\n            test = /.*/,\r\n            minFileSize = 0,\r\n            maxFileSize = Infinity,\r\n            cacheFolder = null,\r\n            disable = false,\r\n            onlyUseIfSmaller = false,\r\n            timeout = 100000,\r\n            externalImages = {},\r\n        } = options\r\n        this.maxConcurrency = cpus().length;\r\n        this.options = {\r\n            testFunction: buildTestFunction(test, minFileSize, maxFileSize),\r\n            cacheFolder,\r\n            onlyUseIfSmaller,\r\n            timeout,\r\n            disable,\r\n            externalImages: {\r\n                context: '.',\r\n                sources: [],\r\n                destination: '.',\r\n                fileName: null,\r\n                ...externalImages\r\n            },\r\n        }\r\n    }\r\n\r\n    apply (compiler) {\r\n        if (this.options.disable === true) return null;\r\n\r\n        this.logger = compiler.getInfrastructureLogger(this.constructor.name);\r\n        this.compilerOptions = compiler.options\r\n        // Access the assets once they have been assembled\r\n        const onEmit = async (compilation, callback) => {\r\n            this.logger = compilation.getLogger(this.constructor.name);\r\n\r\n            // Create a throttle object which will limit the number of concurrent processes running\r\n            const throttle = createThrottle(this.maxConcurrency)\r\n\r\n            try {\r\n                // Optimise all images at the same time (throttled to maxConcurrency)\r\n                // and await until all of them to complete\r\n                // await Promise.all([\r\n                //     ...this.optimizeWebpackImages(throttle, compilation),\r\n                //     // ...this.optimizeExternalImages(throttle)\r\n                // ])\r\n                await this.optimizeWebpackImages(throttle, compilation);\r\n                // At this point everything is done, so call the callback without anything in it\r\n                callback()\r\n            } catch (err) {\r\n                console.log(err);\r\n                // if at any point we hit a snag, pass the error on to webpack\r\n                callback(err)\r\n            }\r\n        }\r\n\r\n        // Check if the webpack 4 plugin API is available\r\n        if (compiler.hooks) {\r\n            // Register emit event listener for webpack 4\r\n            compiler.hooks.emit.tapAsync(this.constructor.name, onEmit)\r\n        } else {\r\n            // Register emit event listener for older webpack versions\r\n            compiler.plugin('emit', onEmit)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Optimize images from webpack and put them back in the asset array when done\r\n     * @param  {Function} throttle       The setup throttle library\r\n     * @param  {Object} compilation      The compilation from webpack-sources\r\n     * @return {Promise[]}               An array of promises that resolve when each image is done being optimized\r\n     */\r\n    async optimizeWebpackImages (throttle, compilation) {\r\n        const {\r\n            testFunction,\r\n            cacheFolder\r\n        } = this.options\r\n\r\n        for (let filename in compilation.assets) {\r\n            const asset = compilation.assets[filename]\r\n            const assetSource = asset.source()\r\n\r\n            if (testFunction(filename, assetSource)) {\r\n                // Use the helper function to get the file from cache if possible, or\r\n                // run the optimize function and store it in the cache when done\r\n                let optimizedImageBuffer = await getFromCacheIfPossible(cacheFolder, assetSource, async () => {\r\n                    return await this.compressor(assetSource, filename);\r\n                })\r\n\r\n                // Then write the optimized version back to the asset object as a \"raw source\"\r\n                compilation.assets[filename] = new RawSource(optimizedImageBuffer)\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Optimizes external images\r\n     * @param  {Function} throttle The setup throttle library\r\n     * @return {Promise[]}         An array of promises that resolve when each image is done being optimized\r\n     */\r\n    async optimizeExternalImages (throttle) {\r\n        const {\r\n            testFunction,\r\n            cacheFolder,\r\n            externalImages: {\r\n                context,\r\n                sources,\r\n                destination,\r\n                fileName\r\n            },\r\n        } = this.options\r\n\r\n        const fullContext = path.resolve(this.compilerOptions.context, context)\r\n\r\n        const invokedDestination = path.resolve(invokeIfFunction(destination))\r\n\r\n        const list = invokeIfFunction(sources);\r\n        for (let i in list) {\r\n            const filename = list[i]\r\n            let relativeFilePath = path.relative(fullContext, filename)\r\n            const fileData = await readFile(path.resolve(fullContext, relativeFilePath))\r\n            if (testFunction(filename, fileData)) {\r\n                // Use the helper function to get the file from cache if possible, or\r\n                // run the optimize function and store it in the cache when done\r\n                let optimizedImageBuffer = await getFromCacheIfPossible(cacheFolder, fileData, async () => {\r\n                    const result = await this.compressor(fileData, filename);\r\n                    return result\r\n                })\r\n\r\n                if (fileName) {\r\n                    relativeFilePath = templatedFilePath(fileName, relativeFilePath)\r\n                }\r\n\r\n                const writeFilePath = path.join(invokedDestination, relativeFilePath)\r\n\r\n                // Write the file to the destination when done\r\n                return writeFile(writeFilePath, optimizedImageBuffer)\r\n            }\r\n        }\r\n    }\r\n\r\n    debug(file, data) {\r\n        if (file.path) {\r\n            this.logger.log(file.path);\r\n        }\r\n\r\n        if (data) {\r\n            this.logger.log('webpack-smushit:', 'Compress rate', '%', data.percent);\r\n            this.logger.log('webpack-smushit:', data.src_size, 'bytes  to  ', data.dest_size, 'bytes');\r\n        }\r\n    }\r\n\r\n    compressor(imageData, filename) {\r\n        const {\r\n            onlyUseIfSmaller,\r\n            timeout,\r\n        } = this.options\r\n\r\n        const imageBuffer = (Buffer.isBuffer(imageData) ? imageData : Buffer.from(imageData, 'utf8'))\r\n        const originalSize = imageBuffer.length\r\n        return new Promise((resolve, reject) => {\r\n            try {\r\n                smosh({contents: imageBuffer, path: filename})\r\n                    .on('end', (optimizedImageBuffer, info) => {\r\n                        this.debug(optimizedImageBuffer, info);\r\n                        if (onlyUseIfSmaller && optimizedImageBuffer.contents.length > originalSize) {\r\n                            return resolve(imageBuffer);\r\n                        }\r\n\r\n                        return resolve(optimizedImageBuffer.contents);\r\n                    })\r\n                    .on('error', (err, file) => {\r\n                        this.logger.log(err);\r\n                        return resolve(imageBuffer)\r\n                    })\r\n\r\n                setTimeout(() => {\r\n                    resolve(imageBuffer)\r\n                }, timeout)\r\n            } catch (e) {\r\n                resolve(imageBuffer)\r\n            }\r\n        });\r\n    }\r\n}\r\n"]}