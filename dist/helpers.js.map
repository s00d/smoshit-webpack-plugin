{"version":3,"sources":["../src/helpers.js"],"names":["buildTestFunction","hashContent","invokeIfFunction","getFromCacheIfPossible","exists","writeFile","templatedFilePath","readFile","fs","writeFileAsync","mkdirpAsync","mkdirp","rawTestValue","minFileSize","maxFileSize","testFunctions","compileRegex","filename","assetSource","func","length","content","crypto","createHash","update","digest","cacheFolder","elseFunc","cacheFilePath","path","resolve","fileBuffer","directory","reject","access","constants","R_OK","W_OK","err","buffer","dirname","tests","Array","isArray","map","test","RegExp","regex","Error","fileName","filePath","originalFilePath","replace","split","basename","extname"],"mappings":";;;;;;;;;;;QAqBgBA,iB,GAAAA,iB;QAsBAC,W,GAAAA,W;QASAC,gB,GAAAA,gB;QAiBMC,sB,GAAAA,sB;QAqBAC,M,GAAAA,M;QAkBAC,S,GAAAA,S;QAyCNC,iB,GAAAA,iB;;AArJhB;;;;AACA;;;;AACA;;;;AACA;;AACA;;;;AACA;;;;;;AAEO,MAAMC,8BAAW,oBAAUC,aAAGD,QAAb,CAAjB;AACP,MAAME,iBAAiB,oBAAUD,aAAGH,SAAb,CAAvB;AACA,MAAMK,cAAc,oBAAUC,gBAAV,CAApB;;AAGA;;;;;;;;;AASO,SAASX,iBAAT,CAA4BY,YAA5B,EAA0CC,WAA1C,EAAuDC,WAAvD,EAAoE;AACvE,UAAMC,gBAAgBC,aAAaJ,YAAb,CAAtB;AACA;;;;;AAKA,WAAO,CAACK,QAAD,EAAWC,WAAX,KAA2B;AAC9B,aAAK,IAAIC,IAAT,IAAiBJ,aAAjB,EAAgC;AAC5B,gBAAII,KAAKF,QAAL,MAAmB,IAAvB,EAA6B;AACzB,uBAAOC,YAAYE,MAAZ,GAAqBP,WAArB,IAAoCK,YAAYE,MAAZ,IAAsBN,WAAjE;AACH;AACJ;AACD,eAAO,KAAP;AACH,KAPD;AAQH;;AAED;;;;;AAKO,SAASb,WAAT,CAAsBoB,OAAtB,EAA+B;AAClC,WAAOC,iBAAOC,UAAP,CAAkB,MAAlB,EAA0BC,MAA1B,CAAiCH,OAAjC,EAA0CI,MAA1C,CAAiD,KAAjD,CAAP;AACH;;AAED;;;;;AAKO,SAASvB,gBAAT,CAA2BiB,IAA3B,EAAiC;AACpC,QAAI,OAAOA,IAAP,KAAgB,UAApB,EAAgC;AAC5B,eAAOA,MAAP;AACH,KAFD,MAEO;AACH,eAAOA,IAAP;AACH;AACJ;;AAED;;;;;;;;;AASO,eAAehB,sBAAf,CAAuCuB,WAAvC,EAAoDL,OAApD,EAA6DM,QAA7D,EAAuE;AAC1E,QAAIC,aAAJ;AACA,QAAIF,gBAAgB,IAApB,EAA0B;AACtBE,wBAAgBC,eAAKC,OAAL,CAAaJ,WAAb,EAA0BzB,YAAYoB,OAAZ,CAA1B,CAAhB;AACA,YAAI,MAAMjB,OAAOwB,aAAP,CAAV,EAAiC;AAC7B,mBAAOrB,SAASqB,aAAT,CAAP;AACH;AACJ;;AAED,UAAMG,aAAa,MAAMJ,UAAzB;AACA,QAAID,gBAAgB,IAApB,EAA0B;AACtB,cAAMrB,UAAUuB,aAAV,EAAyBG,UAAzB,CAAN;AACH;AACD,WAAOA,UAAP;AACH;;AAED;;;;;AAKO,eAAe3B,MAAf,CAAuB4B,SAAvB,EAAkC;AACrC,WAAO,sBAAY,CAACF,OAAD,EAAUG,MAAV,KAAqB;AACpCzB,qBAAG0B,MAAH,CAAUF,SAAV,EAAqBxB,aAAG2B,SAAH,CAAaC,IAAb,GAAoB5B,aAAG2B,SAAH,CAAaE,IAAtD,EAA6DC,GAAD,IAAS;AACjE,gBAAIA,GAAJ,EAAS;AACLR,wBAAQ,KAAR;AACH,aAFD,MAEO;AACHA,wBAAQ,IAAR;AACH;AACJ,SAND;AAOH,KARM,CAAP;AASH;;AAED;;;;;;AAMO,eAAezB,SAAf,CAA0BY,QAA1B,EAAoCsB,MAApC,EAA4C;AAC/C,UAAMP,YAAYH,eAAKW,OAAL,CAAavB,QAAb,CAAlB;AACA;AACA,QAAI,EAAE,MAAMb,OAAO4B,SAAP,CAAR,CAAJ,EAAgC;AAC5B,cAAMtB,YAAYsB,SAAZ,CAAN;AACH;;AAED,WAAOvB,eAAeQ,QAAf,EAAyBsB,MAAzB,CAAP;AACH;;AAED;;;;;AAKA,SAASvB,YAAT,CAAuBJ,YAAvB,EAAqC;AACjC,UAAM6B,QAAQC,MAAMC,OAAN,CAAc/B,YAAd,IAA8BA,YAA9B,GAA6C,CAACA,YAAD,CAA3D;;AAEA,WAAO6B,MAAMG,GAAN,CAAWC,IAAD,IAAU;AACvB,YAAI,OAAOA,IAAP,KAAgB,UAApB,EAAgC;AAC5B;AACA,mBAAOA,IAAP;AACH,SAHD,MAGO,IAAIA,gBAAgBC,MAApB,EAA4B;AAC/B;AACA,mBAAQ7B,QAAD,IAAc4B,KAAKA,IAAL,CAAU5B,QAAV,CAArB;AACH,SAHM,MAGA,IAAI,OAAO4B,IAAP,KAAgB,QAApB,EAA8B;AACjC;AACA,kBAAME,QAAQ,uBAAOF,IAAP,CAAd;AACA,mBAAQ5B,QAAD,IAAc8B,MAAMF,IAAN,CAAW5B,QAAX,CAArB;AACH,SAJM,MAIA;AACH,kBAAM,IAAI+B,KAAJ,CAAU,mFAAV,CAAN;AACH;AACJ,KAdM,CAAP;AAeH;;AAED;;;;;;AAMO,SAAS1C,iBAAT,CAA4B2C,QAA5B,EAAsCC,QAAtC,EAAgD;AACnD,QAAI,OAAOD,QAAP,KAAoB,UAAxB,EAAoC;AAChC,eAAOA,SAASC,QAAT,CAAP;AACH;;AAED,QAAI,OAAOD,QAAP,KAAoB,QAAxB,EAAkC;AAC9B,cAAME,mBAAmBD,QAAzB;;AAEA,eAAOD,SACFG,OADE,CACM,QADN,EACgBD,iBAAiBE,KAAjB,CAAuBxB,eAAKyB,QAAL,CAAcH,gBAAd,CAAvB,EAAwD,CAAxD,CADhB,EAEFC,OAFE,CAEM,QAFN,EAEgBvB,eAAKyB,QAAL,CAAcH,gBAAd,EAAgCtB,eAAK0B,OAAL,CAAaJ,gBAAb,CAAhC,CAFhB,EAGFC,OAHE,CAGM,OAHN,EAGevB,eAAK0B,OAAL,CAAaJ,gBAAb,EAA+BE,KAA/B,CAAqC,GAArC,EAA0C,CAA1C,CAHf,CAAP;AAIH;;AAED,UAAM,IAAIL,KAAJ,CAAU,mDAAV,CAAN;AACH","file":"helpers.js","sourcesContent":["import fs from 'fs'\r\nimport path from 'path'\r\nimport crypto from 'crypto'\r\nimport { makeRe } from 'minimatch'\r\nimport mkdirp from 'mkdirp'\r\nimport promisify from 'util.promisify'\r\n\r\nexport const readFile = promisify(fs.readFile)\r\nconst writeFileAsync = promisify(fs.writeFile)\r\nconst mkdirpAsync = promisify(mkdirp)\r\n\r\n\r\n/**\r\n * Tests a filename to see if it matches any of the given test functions\r\n * This function is curried, pass in the first 3 params first, then the next 2\r\n * for each test needed\r\n * @param  {RegExp|RegExp[]|Function|Function[]|String|String[]} rawTestValue\r\n * @param  {Number} minFileSize\r\n * @param  {Number} maxFileSize\r\n * @return {Boolean}\r\n */\r\nexport function buildTestFunction (rawTestValue, minFileSize, maxFileSize) {\r\n    const testFunctions = compileRegex(rawTestValue)\r\n    /**\r\n     * @param  {String}      filename\r\n     * @param  {assetSource} assetSource\r\n     * @return {Boolean}\r\n     */\r\n    return (filename, assetSource) => {\r\n        for (let func of testFunctions) {\r\n            if (func(filename) === true) {\r\n                return assetSource.length > minFileSize && assetSource.length <= maxFileSize\r\n            }\r\n        }\r\n        return false\r\n    }\r\n}\r\n\r\n/**\r\n * hashes file contents to make sure I can uniquely store a file even with absolute paths\r\n * @param  {string} content  File contents\r\n * @return {string}          A hash of the full file contents\r\n */\r\nexport function hashContent (content) {\r\n    return crypto.createHash('sha1').update(content).digest('hex')\r\n}\r\n\r\n/**\r\n * Invokes the passed in argument if it's a function\r\n * @param  {Function|Any}  func\r\n * @return {Any}\r\n */\r\nexport function invokeIfFunction (func) {\r\n    if (typeof func === 'function') {\r\n        return func()\r\n    } else {\r\n        return func\r\n    }\r\n}\r\n\r\n/**\r\n * Gets the buffer of the file from cache. If it doesn't exist or the cache is\r\n * not enabled, it will invoke elseFunc and use it's result as the result of the\r\n * function, saving the result in the cache\r\n * @param  {String} cacheFolder\r\n * @param  {String} content\r\n * @param  {Function} elseFunc\r\n * @return {Buffer}\r\n */\r\nexport async function getFromCacheIfPossible (cacheFolder, content, elseFunc) {\r\n    let cacheFilePath\r\n    if (cacheFolder !== null) {\r\n        cacheFilePath = path.resolve(cacheFolder, hashContent(content))\r\n        if (await exists(cacheFilePath)) {\r\n            return readFile(cacheFilePath)\r\n        }\r\n    }\r\n\r\n    const fileBuffer = await elseFunc()\r\n    if (cacheFolder !== null) {\r\n        await writeFile(cacheFilePath, fileBuffer)\r\n    }\r\n    return fileBuffer\r\n}\r\n\r\n/**\r\n * checks if a file/directory is accessable\r\n * @param {any} directory\r\n * @returns\r\n */\r\nexport async function exists (directory) {\r\n    return new Promise((resolve, reject) => {\r\n        fs.access(directory, fs.constants.R_OK | fs.constants.W_OK, (err) => {\r\n            if (err) {\r\n                resolve(false)\r\n            } else {\r\n                resolve(true)\r\n            }\r\n        })\r\n    })\r\n}\r\n\r\n/**\r\n * async wrapper for writeFile that will create the directory if it does not already exist\r\n * @param {String} filename\r\n * @param {Buffer} buffer\r\n * @returns\r\n */\r\nexport async function writeFile (filename, buffer) {\r\n    const directory = path.dirname(filename)\r\n    // if the directory doesn't exist, create it\r\n    if (!(await exists(directory))) {\r\n        await mkdirpAsync(directory)\r\n    }\r\n\r\n    return writeFileAsync(filename, buffer)\r\n}\r\n\r\n/**\r\n * Compiles a regex, glob, function, or an array of any of them to an array of functions\r\n * @param  {RegExp|RegExp[]|Function|Function[]|String|String[]} rawTestValue\r\n * @return {Function[]}\r\n */\r\nfunction compileRegex (rawTestValue) {\r\n    const tests = Array.isArray(rawTestValue) ? rawTestValue : [rawTestValue]\r\n\r\n    return tests.map((test) => {\r\n        if (typeof test === 'function') {\r\n            // if it's a function, just return this\r\n            return test\r\n        } else if (test instanceof RegExp) {\r\n            // If it's a regex return it wrapped in a function\r\n            return (filename) => test.test(filename)\r\n        } else if (typeof test === 'string') {\r\n            // If it's a string, let minimatch convert it to a regex then wrap that in a function\r\n            const regex = makeRe(test)\r\n            return (filename) => regex.test(filename)\r\n        } else {\r\n            throw new Error('test parameter must be a regex, glob string, function, or an array of any of them')\r\n        }\r\n    })\r\n}\r\n\r\n/**\r\n * Replaces file name templates for a given path. Inspired by webpack's output.filename config.\r\n * @param {String|Function} fileName\r\n * @param {String} filePath\r\n * @returns {String}\r\n */\r\nexport function templatedFilePath (fileName, filePath) {\r\n    if (typeof fileName === 'function') {\r\n        return fileName(filePath)\r\n    }\r\n\r\n    if (typeof fileName === 'string') {\r\n        const originalFilePath = filePath\r\n\r\n        return fileName\r\n            .replace('[path]', originalFilePath.split(path.basename(originalFilePath))[0])\r\n            .replace('[name]', path.basename(originalFilePath, path.extname(originalFilePath)))\r\n            .replace('[ext]', path.extname(originalFilePath).split('.')[1])\r\n    }\r\n\r\n    throw new Error('fileName parameter must be a string or a function')\r\n}\r\n"]}